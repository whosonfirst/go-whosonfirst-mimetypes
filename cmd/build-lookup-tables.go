package main

import (
	"bufio"
	"flag"
	"io"
	"log"
	"net/http"
	"os"
	"regexp"
	"strings"
	"text/template"
	"time"
)

func render(writer io.Writer, lookup_var string, lookup_table map[string][]string) error {

	tpl := `package lookup

// This file was generated by robots on {{ .LastModified }}

var By{{ .LookupVar }} = map[string][]string{
	{{ range $k, $v := .LookupTable}}"{{ $k }}": []string{ {{ range $vv := $v }}"{{ $vv }}",{{ end }} },
	{{ end }}
}`

	t := template.New("lookup")
	t, err := t.Parse(tpl)

	if err != nil {
		return err
	}

	now := time.Now()
	lastmod := now.Format(time.RFC3339)

	vars := struct {
		LastModified string
		LookupVar    string
		LookupTable  map[string][]string
	}{
		LastModified: lastmod,
		LookupVar:    lookup_var,
		LookupTable:  lookup_table,
	}

	return t.Execute(os.Stdout, vars)
}

func main() {

	var source = flag.String("source", "https://svn.apache.org/viewvc/httpd/httpd/branches/2.2.x/docs/conf/mime.types?view=co", "Where to read default mime type mappings from")
	var lookup = flag.String("lookup", "extension", "")

	flag.Parse()

	switch *lookup {
	case "extension":
		// pass
	case "mimetype":
		// pass
	default:
		log.Fatal("Invalid lookup type")
	}

	rsp, err := http.Get(*source)

	if err != nil {
		log.Fatal(err)
	}

	defer rsp.Body.Close()

	lookup_table := make(map[string][]string)

	re, err := regexp.Compile(`\s{2,}`)

	if err != nil {
		log.Fatal(err)
	}

	scanner := bufio.NewScanner(rsp.Body)

	for scanner.Scan() {

		ln := scanner.Text()

		if strings.HasPrefix(ln, "#") {
			continue
		}

		ln = re.ReplaceAllString(ln, " ")
		parts := strings.Split(ln, " ")

		m := parts[0]
		e := parts[1:]

		switch *lookup {
		case "mimetype":
			lookup_table[m] = e
		case "extension":

			for _, x := range e {

				_, ok := lookup_table[x]

				if ok {
					lookup_table[x] = append(lookup_table[x], m)
				} else {
					lookup_table[x] = []string{m}
				}
			}

		default:
			// we should never get here
		}
	}

	// TO DO : append missing here

	lookup_var := strings.ToTitle(*lookup)
	writer := os.Stdout

	err = render(writer, lookup_var, lookup_table)

	if err != nil {
		log.Fatal(err)
	}

	os.Exit(0)
}
